<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Introduction</title>
</head>

<body>

<p>Interacx - Schema Driven Client/Server Automation For Web Applications</p>
<h2>Introduction</h2>
<p>The website I'm working on for a client involves a lot of grids and data 
entry forms for managing users, meeting, participants, and so forth.&nbsp; All 
of this requires defining data sources, binding elements to the jqWidgets 
controls, and creating JSON objects for the AJAX postbacks.&nbsp; This is all 
essentially a repeatable pattern based on the &quot;view schema&quot; for each grid.&nbsp; 
Not only is this a repeatable pattern for each grid, but several components of 
the grid are themselves essentially repetitive information.&nbsp; I do not like 
repeating myself.</p>
<p>Furthermore, the &quot;view schema&quot; is essentially the equivalent of a database 
view -- a composite of tables joined by their foreign key relationships.&nbsp; 
So the other half of the coin here is to automate the CRUD operations on the 
back end that support the user interactions on the front end.&nbsp; The usual 
approach, an ORM, again an exercise in repetition and unnecessary steps: create 
a model in code (but wait, we already have a schema in the database, don't we?), 
load the data into an object (models are basically just glorified bags in most 
cases), translate the model into JSON (can't we just translate a DataTable into 
JSON?&nbsp; Why, yes we can!) and ship it off to the client when it requests the 
data.&nbsp; Again, I do not like repeating myself.</p>
<p>In this article, I am going to do demonstrate two things:</p>
<ol>
	<li>How to generate, using a &quot;view schema&quot;, all the pieces to dynamically 
	render a grid and the popup &quot;add record&quot; form.</li>
	<li>How to use a lightweight No-Orm SQL generator on the backend for the 
	CRUD operations</li>
</ol>
<p>The foundation of this technique is the &quot;view schema.&quot;&nbsp; In Part II, I 
will demonstrate creating and managing view schemas in the browser and how your 
application can immediately reflect changes made to the view schema--a nice 
feature for when the customer asks (for example) &quot;can I add a this field&quot; or 
&quot;can we move this column over to <i>here</i>.&quot;</p>
<p>The various components that I'll be covering in this article are illustrated 
in this diagram:</p>
<p align="center">
<img border="0" src="architecture.png" width="564" height="420"></p>
<p align="left">
We'll begin by looking at the manually created grid and what we need to do to 
make it respond dynamically to a view schema.</p>
<h2>Redundancy: Come Join the Dark Side</h2>
<p><img border="0" src="grid1.png" width="803" height="211"></p>
<p>Here we have jqxGrid control with a variety of features.&nbsp; Besides the 
sorting, column grouping, and column sizing configuration options, the above 
screenshot illustrates several different types of data:</p>
<ul>
	<li>Checkboxes for whether the account is disabled or not</li>
	<li>A date/time field, which is read-only</li>
	<li>A dropdown for the user's role</li>
	<li>Text input</li>
<li><font color="#FF0000">Masked input for the phone number</font></li>
</ul>
<p>While the grid cells are editable and post back immediately to the server, we 
use a popup window for creating new users:</p>
<p><img border="0" src="input1.png" width="502" height="321"></p>
<p>Looking at the page's source code, we see several redundancies.</p>
<h3>Initialization of the New User popup Controls</h3>
<p>Here we see binding the jqWidget controls to the HTML elements using the 
element ID's:</p>
<pre>$('#UserName').jqxInput({ width: '200px', height: '20px', theme: theme, width: &quot;100%&quot; })
$('#Email').jqxInput({ width: '200px', height: '20px', theme: theme, width: &quot;100%&quot; })
$('#FirstName').jqxInput({ width: '200px', height: '20px', theme: theme, width: &quot;100%&quot; })
$('#LastName').jqxInput({ width: '200px', height: '20px', theme: theme, width: &quot;100%&quot; })
$('#Phone').jqxInput({ width: '200px', height: '20px', theme: theme, width: &quot;100%&quot; })
$('#Password').jqxPasswordInput({ width: '200px', height: '20px', showStrength: false, showStrengthPosition: 'right', theme: theme, width: &quot;100%&quot; })
$(&quot;#RoleName&quot;).jqxComboBox({ source: ['Super Admin', 'Admin', 'Analyst', 'Guest'], selectedIndex: 4, height: '20px', width: '100%' })</pre>
<p>Notice also the hard-coded combobox list.</p>
<h3>Initialization of Rules</h3>
<p>Here we see validation rules being initialized:</p>
<pre>$('#newUser').jqxValidator({
  rules: [
    { input: '#UserName', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#Email', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#FirstName', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#LastName', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#Password', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    ], hintType: 'label'
});</pre>
<h3>Datasource Initialization</h3>
<p>Here the datasource is initialized and the jqxGrid will use an AJAX call to 
populate the grid:</p>
<pre>var source =
{
  dataType: &quot;json&quot;,
  dataFields: [
    { name: 'Id', type: 'integer' },
    { name: 'UserName', type: 'string' },
    { name: 'RoleName', type: 'string' },
    { name: 'Email', type: 'string' },
    { name: 'Phone', type: 'string' },
    { name: 'FirstName', type: 'string' },
    { name: 'LastName', type: 'string' },
    { name: 'Disabled', type: 'bool' },
    { name: 'LastSignOn', type: 'date' },
    { name: 'RoleName', type: 'string' }
  ],
  id: 'Id',
  url: '/admin/userlist'
};</pre>
<h3>Column Definitions</h3>
<p>Yet again, we see a similar list of fields, this time to initialize the 
columns.&nbsp; If you get the idea or are just getting bored, feel free to skip 
ahead.&nbsp; But don't forget, I had to type all this stuff in!</p>
<pre>columns: [
  { text: 'User Name', datafield: 'UserName', width: '10%', align: 'center' },
  { text: 'Role', datafield: 'RoleName', width: '10%', align: 'center',
    columntype: 'dropdownlist',
    createeditor: function (row, cellvalue, editor) {
      editor.jqxDropDownList({ source: ['Super Admin', 'BMBFA Admin', 'Center Admin', 'Analyst', 'Guest'] })
    },
  },
  { text: 'Last Sign On', datafield: 'LastSignOn', columntype: 'datetime', width: '15%', cellsformat: 'MM/dd/yyyy hh:mm tt', 
      align: 'center', editable: false, filtertype: 'range' },
  { text: 'Disabled', datafield: 'Disabled', columntype: 'checkbox', width: '10%', align: 'center', filtertype: 'bool' },
  { text: 'First Name', datafield: 'FirstName', width: '15%', columngroup: 'Name', align: 'center' },
  { text: 'Last Name', datafield: 'LastName', width: '15%', columngroup: 'Name', align: 'center' },
  { text: 'Email', datafield: 'Email', width: '15%', columngroup: 'Contact', align: 'center' },
  { text: 'Phone', datafield: 'Phone', width: '10%', columngroup: 'Contact', align: 'center' }
],
columngroups: [
  { text: 'Name', name: 'Name', align: 'center' },
  { text: 'Contact', name: 'Contact', align: 'center' }
]</pre>
<h3>Data For Create User Callback</h3>
<p>And again, here we create key-value pairs for the AJAX callback when creating 
a user:</p>
<pre>var datarow = {
  UserName: $(&quot;#UserName&quot;).val(),
  Email: $(&quot;#Email&quot;).val(),
  FirstName: $(&quot;#FirstName&quot;).val(),
  LastName: $(&quot;#LastName&quot;).val(),
  Phone: $(&quot;#Phone&quot;).val(),
  Password: $(&quot;#Password&quot;).val(),
  RoleName: $(&quot;#RoleName&quot;).val()
}</pre>
<h3>Last But Not Least, the HTML</h3>
<p>And finally, we have the HTML for the popup window:</p>
<pre>&lt;div id=&quot;newUser&quot;&gt;
  &lt;div&gt;New User&lt;/div&gt;
    &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-4 padding-top4'&gt;User Name:&lt;/div&gt;
      &lt;div class='col-sm-6'&gt;&lt;input style='padding-left:3px' id='UserName'/&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-4 padding-top4'&gt;Role:&lt;/div&gt;
      &lt;div class='col-sm-6' &gt;
        &lt;div id=&quot;RoleName&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-4 padding-top4'&gt;Email:&lt;/div&gt;
      &lt;div class='col-sm-6'&gt;&lt;input style='padding-left:3px' id='Email'/&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-4 padding-top4'&gt;First Name:&lt;/div&gt;
      &lt;div class='col-sm-6'&gt;&lt;input style='padding-left:3px' id='FirstName'/&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-4 padding-top4'&gt;Last Name:&lt;/div&gt;
      &lt;div class='col-sm-6'&gt;&lt;input style='padding-left:3px' id='LastName'/&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-4 padding-top4'&gt;Phone:&lt;/div&gt;
      &lt;div class='col-sm-6'&gt;&lt;input style='padding-left:3px' id='Phone'/&gt;&lt;/div&gt;
    &lt;/div&gt;
      &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-4 padding-top4'&gt;Password:&lt;/div&gt;
      &lt;div class='col-sm-6'&gt;&lt;input style='padding-left:3px' id='Password' type='password'/&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class='row rowlabel' style='width:100%;'&gt;
      &lt;div class='col-sm-12 padding-top4 center-text'&gt;
        &lt;input type=&quot;button&quot; id=&quot;Save&quot; value=&quot;Save&quot;/&gt;
        &lt;input type=&quot;button&quot; id=&quot;Cancel&quot; value=&quot;Cancel&quot;/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
<h2>Do You See The Redundancy?</h2>
<p>Hopefully, you see the pattern of redundancy here, in that all these aspects 
of the page source:</p>
<ul>
	<li>Initialization of controls</li>
	<li>Initialization of rules</li>
	<li>Datasource initialization</li>
	<li>Column definitions</li>
	<li>Data for the create user callback</li>
	<li>The HTML itself</li>
</ul>
<p>All of this has been written manually.&nbsp; <b>And all of that error prone 
typing would be unnecessary if we were smart about how we did things and used a 
view schema</b>--metadata if you will.&nbsp; <b>Furthermore, don't forget that 
this view schema will also be used to generate the SQL for the CRUD operations</b> 
-- we're also eliminating redundancy on the server-side as well!</p>
<h3>Fixing Control Initialization</h3>
<p>Let's start correcting this problem by defining some JSON for initializing 
the &quot;new user&quot; controls.&nbsp; The first thing we need is an array of fields and 
at a minimum, some indication as to how to render the field:</p>
<pre>var view = '{&quot;fields&quot;: ['+
  '{&quot;name&quot;: &quot;Id&quot;},'+
  '{&quot;name&quot;: &quot;UserName&quot;, &quot;render&quot;: &quot;input&quot;},'+
  '{&quot;name&quot;: &quot;RoleName&quot;, &quot;render&quot;: &quot;lookup&quot;, &quot;initialselection&quot;: 3, &quot;lookupdata&quot;:'+
  '['+
    '{&quot;value&quot;: &quot;Super Admin&quot;},'+
    '{&quot;value&quot;: &quot;Admin&quot;},'+
    '{&quot;value&quot;: &quot;Analyst&quot;},'+
    '{&quot;value&quot;: &quot;Guest&quot;}'+
    ']},'+
  '{&quot;name&quot;: &quot;Password&quot;, &quot;render&quot;: &quot;password&quot;},'+
  '{&quot;name&quot;: &quot;Email&quot;, &quot;render&quot;: &quot;input&quot;},'+
  '{&quot;name&quot;: &quot;FirstName&quot;, &quot;render&quot;: &quot;input&quot;},'+
  '{&quot;name&quot;: &quot;LastName&quot;, &quot;render&quot;: &quot;input&quot;},'+
  '{&quot;name&quot;: &quot;Phone&quot;, &quot;render&quot;: &quot;input&quot;},' +
  '{&quot;name&quot;: &quot;Disabled&quot;},'+
  '{&quot;name&quot;: &quot;LastSignOn&quot;}' +
']}'
var json = JSON.parse(view)</pre>
<p>Instead of the manual initialization of the controls, we'll now initialize 
controls which define a &quot;render&quot; key:</p>
<pre>function ixBindControls(view, theme) {
  var fields = view.fields
  for (var i = 0; i &lt; fields.length; i++) {
    var field = fields[i]
    var fieldId = &quot;#&quot; + field.name
    var element = $(fieldId)

    switch (field.render) {
      case &quot;input&quot;:
        element.jqxInput({ width: '200px', height: '20px', theme: theme, width: &quot;100%&quot; })
        break
      case &quot;lookup&quot;:
        element.jqxComboBox({ source: field.lookupdata, selectedIndex: field.initialselection, height: '20px', width: '100%' })
        break
      case &quot;password&quot;:
        element.jqxPasswordInput({ height: '20px', showStrength: false, showStrengthPosition: 'right', theme: theme, width: &quot;100%&quot; })
        break;
      case &quot;checkbox&quot;:
        element.jqxCheckBox({ theme: theme })
        break
      case &quot;datetime&quot;:
        element.jqxDateTime({theme: theme})
        break;
    }
  }
}</pre>
<p>For the moment, let's ignore various hardcoded options like width and height 
and just focus on the concept of a view schema eliminating redundancy.&nbsp; We 
replace all the hardcoded control initialization with:</p>
<pre>ixBindControls(json, theme)</pre>
<h3>Fixing Rule Initialization</h3>
<p>Rules can get really complicated, but let's say that the main concern at the 
moment is the &quot;field required&quot; rule.&nbsp; Again, we'll take the code shown 
earlier:</p>
<pre>$('#newUser').jqxValidator({
  rules: [
    { input: '#UserName', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#Email', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#FirstName', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#LastName', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    { input: '#Password', message: 'Required field', action: 'keyup, blur', rule: 'required' },
    ], hintType: 'label'
});</pre>

<p>We'll add an optional &quot;required&quot; key to the view definition:</p>
<pre>var view = '{&quot;fields&quot;: ['+
  '{&quot;name&quot;: &quot;Id&quot;},'+
  '{&quot;name&quot;: &quot;UserName&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},'+
  '{&quot;name&quot;: &quot;RoleName&quot;, &quot;render&quot;: &quot;lookup&quot;, &quot;initialselection&quot;: 3, &quot;lookupdata&quot;:'+
  '['+
    '{&quot;value&quot;: &quot;Super Admin&quot;},'+
    '{&quot;value&quot;: &quot;Admin&quot;},'+
    '{&quot;value&quot;: &quot;Analyst&quot;},'+
    '{&quot;value&quot;: &quot;Guest&quot;}'+
    ']},'+
  '{&quot;name&quot;: &quot;Password&quot;, &quot;render&quot;: &quot;password&quot;, &quot;required&quot;: true},'+
  '{&quot;name&quot;: &quot;Email&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},'+
  '{&quot;name&quot;: &quot;FirstName&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},'+
  '{&quot;name&quot;: &quot;LastName&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},'+
  '{&quot;name&quot;: &quot;Phone&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},' +
  '{&quot;name&quot;: &quot;Disabled&quot;},'+
  '{&quot;name&quot;: &quot;LastSignOn&quot;}' +
']}'
<p>And write a function to initialize the rules:</p>
<p>&nbsp;</p>
<p></p>
<p>We replace the above with:</p>
<pre>$('#newUser').jqxValidator({rules: ixGetRules(json), hintType: 'label'});</pre>
<h3>Fixing DataSource Initialization</h3>
<p>Earlier, we saw this:</p>
<pre>dataFields: [
  { name: 'Id', type: 'integer' },
  { name: 'UserName', type: 'string' },
  { name: 'RoleName', type: 'string' },
  { name: 'Email', type: 'string' },
  { name: 'Phone', type: 'string' },
  { name: 'FirstName', type: 'string' },
  { name: 'LastName', type: 'string' },
  { name: 'Disabled', type: 'bool' },
  { name: 'LastSignOn', type: 'date' },
  { name: 'RoleName', type: 'string' }
],</pre>
<p>We will now add field type information to our view:</p>
<pre>var view = '{&quot;fields&quot;: ['+
  '{&quot;name&quot;: &quot;Id&quot;, &quot;type&quot;: &quot;integer&quot;},'+
  '{&quot;name&quot;: &quot;UserName&quot;, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},' +
  '{&quot;name&quot;: &quot;RoleName&quot;, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;lookup&quot;, &quot;initialselection&quot;: 3, &quot;lookupdata&quot;:' +
  '['+
    '{&quot;value&quot;: &quot;Super Admin&quot;},'+
    '{&quot;value&quot;: &quot;Admin&quot;},'+
    '{&quot;value&quot;: &quot;Analyst&quot;},'+
    '{&quot;value&quot;: &quot;Guest&quot;}'+
    ']},'+
  '{&quot;name&quot;: &quot;Password&quot;, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;password&quot;, &quot;required&quot;: true},' +
  '{&quot;name&quot;: &quot;Email&quot;, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},' +
  '{&quot;name&quot;: &quot;FirstName&quot;, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},' +
  '{&quot;name&quot;: &quot;LastName&quot;, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},' +
  '{&quot;name&quot;: &quot;Phone&quot;, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true},' +
  '{&quot;name&quot;: &quot;Disabled&quot;, &quot;type&quot;: &quot;bool&quot;},' +
  '{&quot;name&quot;: &quot;LastSignOn&quot;, &quot;type&quot;: &quot;date&quot;}' +
']}'</pre>
<p>We'll need a function to build the data source array:</p>
<pre>function ixGetDataFields(view) {
  var fields = view.fields
  var datafields = []

  for (var i = 0; i &lt; fields.length; i++) {
    var field = fields[i]
    var datafield = { name: field.name, type: field.type }
    datafields.push(datafield)
  }

  return datafields
}</pre>
<p>And we can replace the initialization of the data fields with:</p>
<pre>var source =
{
  dataType: &quot;json&quot;,
  dataFields: ixGetDataFields(json),
  id: 'Id',
  url: '/admin/userlist'
};</pre>
<h3>Fixing Column Definitions</h3>
<p>Let's look again at the hand-coded column definitions for the grid:</p>
<pre>columns: [
  { text: 'User Name', datafield: 'UserName', width: '10%', align: 'center' },
  { text: 'Role', datafield: 'RoleName', width: '10%', align: 'center',
    columntype: 'dropdownlist',
    createeditor: function (row, cellvalue, editor) {
      editor.jqxDropDownList({ source: ['Super Admin', 'BMBFA Admin', 'Center Admin', 'Analyst', 'Guest'] })
    },
  },
  { text: 'Last Sign On', datafield: 'LastSignOn', columntype: 'datetime', width: '15%', cellsformat: 'MM/dd/yyyy hh:mm tt', 
      align: 'center', editable: false, filtertype: 'range' },
  { text: 'Disabled', datafield: 'Disabled', columntype: 'checkbox', width: '10%', align: 'center', filtertype: 'bool' },
  { text: 'First Name', datafield: 'FirstName', width: '15%', columngroup: 'Name', align: 'center' },
  { text: 'Last Name', datafield: 'LastName', width: '15%', columngroup: 'Name', align: 'center' },
  { text: 'Email', datafield: 'Email', width: '15%', columngroup: 'Contact', align: 'center' },
  { text: 'Phone', datafield: 'Phone', width: '10%', columngroup: 'Contact', align: 'center' }
],
columngroups: [
  { text: 'Name', name: 'Name', align: 'center' },
  { text: 'Contact', name: 'Contact', align: 'center' }
]</pre>
<p>We can see that we'll need the following fields in the view schema:</p>
<ul>
	<li>caption</li>
	<li>format</li>
	<li>filter type</li>
	<li>group</li>
	<li>width</li>
	<li>alignment</li>
	<li>readonly</li>
	<li>visible (may be hidden on the grid but visible in the &quot;new record&quot; form, 
	or vice-versa!)</li>
</ul>
<p>We also need to consider the ordering of the columns for the grid, which may 
be different than the ordering of the columns for a &quot;new record&quot; form.&nbsp; 
The jqxGrid control orders the columns in the same order in which they are 
defined -- there is no separate column order attributes.&nbsp; </p>
<p>We'll first fuss with the JSON view again, putting these fields as 
appropriate into a &quot;grid&quot; subsection of each field:</p>
<pre>var view = '{&quot;fields&quot;: [' +
  '{&quot;name&quot;: &quot;Id&quot;, &quot;type&quot;: &quot;integer&quot;},' +
  '{&quot;name&quot;: &quot;UserName&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true, &quot;caption&quot;: &quot;User Name&quot;, ' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;10%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;order&quot;: 0}' +
  '},' +
  '{&quot;name&quot;: &quot;LastSignOn&quot;, &quot;caption&quot;:&quot;Last Sign On&quot;, &quot;readonly&quot;:true, &quot;type&quot;: &quot;date&quot;, &quot;render&quot;:&quot;datetime&quot;, ' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;15%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;format&quot;: &quot;MM/dd/yyyy hh:mm tt&quot;, &quot;order&quot;: 1}' +
  '},' +
  '{&quot;name&quot;: &quot;RoleName&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;lookup&quot;, &quot;caption&quot;: &quot;Role&quot;, &quot;initialselection&quot;: 3, &quot;lookupdata&quot;:' +
    '[' +
      '{&quot;value&quot;: &quot;Super Admin&quot;},' +
      '{&quot;value&quot;: &quot;Admin&quot;},' +
      '{&quot;value&quot;: &quot;Analyst&quot;},' +
      '{&quot;value&quot;: &quot;Guest&quot;}' +
    '], ' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;10%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;order&quot;: 2}' +
  '},' +
  '{&quot;name&quot;: &quot;Password&quot;, &quot;caption&quot;:&quot;Password&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;password&quot;, &quot;required&quot;: true, ' +
    '&quot;grid&quot;:{&quot;visible&quot;:false}' +
  '},' +
  '{&quot;name&quot;: &quot;Disabled&quot;, &quot;render&quot;:&quot;checkbox&quot;, &quot;caption&quot;:&quot;Disabled?&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;bool&quot;,' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;10%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;order&quot;: 3}' +
  '},' +
  '{&quot;name&quot;: &quot;FirstName&quot;, &quot;caption&quot;: &quot;First Name&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true,' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;15%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;columngroup&quot;:&quot;Name&quot;, &quot;order&quot;: 4}' +
  '},' +
  '{&quot;name&quot;: &quot;LastName&quot;, &quot;caption&quot;:&quot;Last Name&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true,' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;15%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;columngroup&quot;:&quot;Name&quot;, &quot;order&quot;: 5}' +
  '},' +
  '{&quot;name&quot;: &quot;Phone&quot;, &quot;caption&quot;:&quot;Phone&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true,' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;10%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;columngroup&quot;:&quot;Contact&quot;, &quot;order&quot;: 6}' +
  '},' +
  '{&quot;name&quot;: &quot;Email&quot;, &quot;caption&quot;: &quot;Email&quot;, &quot;readonly&quot;:false, &quot;type&quot;: &quot;string&quot;, &quot;render&quot;: &quot;input&quot;, &quot;required&quot;: true,' +
    '&quot;grid&quot;:{&quot;width&quot;:&quot;15%&quot;, &quot;align&quot;:&quot;center&quot;, &quot;columngroup&quot;:&quot;Contact&quot;, &quot;order&quot;: 7}' +
  '}' +
']}'</pre>
<p>While the JSON starts to look mind-numbing and daunting, keep in mind that 
most of it will be auto-generated on the server-side from the database schema 
and metadata attached to the schema along with a variety of default behaviors, 
and ultimately, we'll have a <i>web page</i> just for managing view schema 
properties!</p>
<p>We also implement a few Javascript functions to automate generating the 
jqxGrid column definition.&nbsp; The Javascript I'm putting together is not the 
most elegant and should, for all practical purposes be considered prototype 
code!&nbsp; However, it gets the job done for now and illustrates the point I'm 
trying to make in this article:</p>
<pre>function ixGetColumnDefinitions(view) {
  var fields = sortGridColumns(view)
  var columns = []

  for (var i = 0; i &lt; fields.length; i++) {
    var field = fields[i]

    if (field.grid !== undefined) {
      // Undefined visibility assumes visible.
      var visible = (field.grid.visible === undefined) ? true : field.grid.visible

      if (visible) {
        switch (field.render) {
          case &quot;input&quot;:
          case &quot;password&quot;:
            var column = {
            text: field.caption,
            datafield: field.name,
            width: field.grid.width,
            align: field.grid.align,
            editable: !field.readonly,
            columngroup: field.grid.columngroup
          }
          columns.push(column)
          break
        case &quot;lookup&quot;:
            var items = field.lookupdata.map(function (elem) {
              return elem.value
            })
  
          var column = {
            text: field.caption,
            datafield: field.name,
            width: field.grid.width,
            align: field.grid.align,
            editable: !field.readonly,
            columngroup: field.grid.columngroup,
            columntype: 'dropdownlist',
            createeditor: function (row, cellvalue, editor) {
              editor.jqxDropDownList({ source: items })
            },
          }
          columns.push(column)
          break
        case &quot;checkbox&quot;:
          var column = {
            text: field.caption,
            datafield: field.name,
            width: field.grid.width,
            align: field.grid.align,
            editable: !field.readonly,
            columngroup: field.grid.columngroup,
            filtertype: 'bool',
            columntype: 'checkbox'
            }
          columns.push(column)
          break
        case &quot;datetime&quot;:
          var column = {
            text: field.caption,
            datafield: field.name,
            width: field.grid.width,
            align: field.grid.align,
            columngroup: field.grid.columngroup,
            cellsformat: field.grid.format,
            editable: !field.readonly,
            filtertype: 'range',
            columntype: 'datetime'
          }
          columns.push(column)
          break;
        default:
          var column = {
            text: field.caption,
            datafield: field.name,
            width: field.grid.width,
            align: field.grid.align,
            editable: !field.readonly,
            columngroup: field.grid.columngroup
          }
          columns.push(column)
          break
        }
      }
    }
  }

  return columns
}

function ixGetColumnGroups(view) {
  var fields = view.fields
  var columnGroups = []

  for (var i = 0; i &lt; fields.length; i++) {
    var field = fields[i]

    if (field.grid !== undefined) {
    // Undefined visibility assumes visible.
      var visible = (field.grid.visible === undefined) ? true : field.grid.visible

      if (visible) {
        if (field.grid.columngroup !== undefined) {
          columnGroups.push(field.grid.columngroup)
        }
      }
    }
  }

  var uniqueColumns = columnGroups.filter(unique)

  for (var i = 0; i &lt; uniqueColumns.length; i++) {
    var columnGroup = {text: uniqueColumns[i], name: uniqueColumns[i], align: 'center'}
    columnGroups.push(columnGroup)
  }

  return columnGroups
}

function unique(value, index, self) {
  return self.indexOf(value) === index;
}

function sortGridColumns(view) {
  var fields = view.fields
  var columns = []

  for (var i = 0; i &lt; fields.length; i++) {
    var field = fields[i]

    if (field.grid !== undefined) {
      // Undefined visibility assumes visible.
      var visible = (field.grid.visible === undefined) ? true : field.grid.visible

      if (visible) {
        columns.push({key:field, order:field.grid.order})
      }
    }
  }

  var sortedFields = columns.sort(function (x, y) { return x.order - y.order }).map(function(f) {return f.key})

  return sortedFields
}          </pre>
<p>Now, the <code>columns</code> and <code>columngroups</code> properties can be initialized like this:</p>
<pre>columns: ixGetColumnDefinitions(json),
columngroups: ixGetColumnGroups(json)
</pre>
<h3>Fixing the HTML</h3>
<p>Let's address the HTML for creating a new record next.&nbsp; What we'll do 
here is first gather up the fields that are relevant to an input form (we'll add 
a subsection similar to &quot;grid&quot; but call it &quot;form&quot;) and then use underscore's 
template engine to render the HTML on the client-side, thus allowing us to 
preserve the control over the styling of the label and input field form. </p>
<h3>Fixing the Create User Callback Data</h3>
<p>Recall that we are posting back the data from the widgets:</p>
<pre>var datarow = {
  UserName: $(&quot;#UserName&quot;).val(),
  Email: $(&quot;#Email&quot;).val(),
  FirstName: $(&quot;#FirstName&quot;).val(),
  LastName: $(&quot;#LastName&quot;).val(),
  Phone: $(&quot;#Phone&quot;).val(),
  Password: $(&quot;#Password&quot;).val(),
  RoleName: $(&quot;#RoleName&quot;).val()
}</pre>
<p>Here we're obviously posting back only the visible, writeable fields.&nbsp; 
We don't need to touch the JSON to handle this, instead we just write a small 
Javascript function that creates this literal object for us:</p>
<h2>Let's Review!</h2>
<p>It would be good to review what we've accomplished so far.</p>
<h3>One Authority on the Rendering of the Grid and New Record Form</h3>
<p>While it can look complicated, what we've achieved is taking six separate 
sections of the HTML page and replacing them with generated data from a single 
JSON data source.&nbsp; One of the immediate benefits of this approach is that 
there is now only one place in the code that needs to be touched when we want to 
change some field specification used by the grid and the new record form.&nbsp; 
We can add and remove fields, re-order them, and adjust some visual aspects of 
the grid and new record form such as captions and column spacing and formatting.&nbsp; </p>
<h3>Reusablity</h3>
<p>Importantly, because this is schema driven, we now have a re-usable solution 
for our grids.&nbsp; </p>
<h3>Reduces Typos and Other Errors</h3>
<p>Because Javascript is an interpreted language and it is so easy to make 
mistakes -- a misplaced quote mark or curly brace, a typo in a variable name 
reference, etc. -- this approach significantly reduces the error prone, fire up 
the browser debugger, process that we all go through when debugging web pages.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>